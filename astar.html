<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>A* Pathfinding Simulation</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overscroll-behavior: none; /* Prevents pull-to-refresh on mobile */
        }
        canvas {
            touch-action: none; /* Prevents default touch actions like scrolling when drawing on canvas */
            border: 1px solid #e2e8f0; /* Tailwind gray-300 */
            border-radius: 0.5rem; /* Tailwind rounded-lg */
        }
        .controls button, .controls select {
            transition: all 0.2s ease-in-out;
        }
        .controls button:hover, .controls select:hover {
            transform: translateY(-1px);
        }
        .controls button:active {
            transform: translateY(0px);
        }
        .modal {
            display: none; /* Hidden by default */
            position: fixed;
            z-index: 100;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.5);
            justify-content: center;
            align-items: center;
        }
        .modal-content {
            background-color: #fefefe;
            margin: auto;
            padding: 20px;
            border: 1px solid #888;
            width: 80%;
            max-width: 500px;
            border-radius: 0.5rem;
            text-align: center;
        }
        .modal-close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }
        /* Custom scrollbar for better aesthetics if content overflows */
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 10px;
        }
        ::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 10px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #555;
        }
    </style>
</head>
<body class="bg-slate-900 text-slate-100 flex flex-col items-center justify-center min-h-screen p-4 selection:bg-sky-500 selection:text-white">

    <div class="w-full max-w-4xl bg-slate-800 p-6 rounded-xl shadow-2xl">
        <header class="mb-6 text-center">
            <h1 class="text-3xl font-bold text-sky-400">A* Pathfinding Simulation</h1>
            <p class="text-slate-400 mt-1">Visualize the A* algorithm finding the shortest path in a grid.</p>
        </header>

        <div class="grid md:grid-cols-3 gap-6 mb-6 controls">
            <div class="flex flex-col space-y-2">
                <label for="tool" class="text-sm font-medium text-slate-300">Select Tool:</label>
                <select id="tool" class="bg-slate-700 border border-slate-600 text-slate-100 text-sm rounded-lg focus:ring-sky-500 focus:border-sky-500 block w-full p-2.5">
                    <option value="start">Set Start Node (Green)</option>
                    <option value="end">Set End Node (Red)</option>
                    <option value="obstacle" selected>Draw Obstacles (Black)</option>
                    <option value="erase">Erase Obstacles</option>
                </select>
            </div>
            <div class="flex flex-col space-y-2">
                <label for="gridSize" class="text-sm font-medium text-slate-300">Grid Size (Cells): <span id="gridSizeLabel">20</span></label>
                 <input type="range" id="gridSize" min="10" max="50" value="20" class="w-full h-2 bg-slate-700 rounded-lg appearance-none cursor-pointer accent-sky-500">
            </div>
            <div class="flex flex-col space-y-2">
                <label for="speed" class="text-sm font-medium text-slate-300">Visualization Speed:</label>
                <select id="speed" class="bg-slate-700 border border-slate-600 text-slate-100 text-sm rounded-lg focus:ring-sky-500 focus:border-sky-500 block w-full p-2.5">
                    <option value="10">Fast</option>
                    <option value="50" selected>Medium</option>
                    <option value="150">Slow</option>
                </select>
            </div>
        </div>

        <div class="flex flex-col md:flex-row gap-4 mb-6 controls items-center justify-center">
            <button id="startButton" class="w-full md:w-auto bg-sky-500 hover:bg-sky-600 text-white font-semibold py-2 px-4 rounded-lg shadow-md focus:outline-none focus:ring-2 focus:ring-sky-400 focus:ring-opacity-75">
                Start A* Search
            </button>
            <button id="resetButton" class="w-full md:w-auto bg-slate-600 hover:bg-slate-500 text-white font-semibold py-2 px-4 rounded-lg shadow-md focus:outline-none focus:ring-2 focus:ring-slate-400 focus:ring-opacity-75">
                Reset Grid
            </button>
            <button id="clearObstaclesButton" class="w-full md:w-auto bg-amber-500 hover:bg-amber-600 text-white font-semibold py-2 px-4 rounded-lg shadow-md focus:outline-none focus:ring-2 focus:ring-amber-400 focus:ring-opacity-75">
                Clear Obstacles
            </button>
        </div>
        
        <div class="mb-4 text-center">
            <p id="status" class="text-slate-400 h-6"></p>
        </div>

        <div class="w-full aspect-square mx-auto max-w-xl lg:max-w-2xl">
             <canvas id="pathfindingCanvas" class="bg-slate-700"></canvas>
        </div>
    </div>

    <div id="messageModal" class="modal">
        <div class="modal-content bg-slate-800 text-slate-100 p-6 rounded-lg shadow-xl">
            <span class="modal-close text-slate-400 hover:text-slate-200">&times;</span>
            <p id="modalMessageText" class="text-lg"></p>
        </div>
    </div>

    <script>
        // --- Modal Functionality ---
        const modal = document.getElementById('messageModal');
        const modalMessageText = document.getElementById('modalMessageText');
        const closeModalButton = document.querySelector('.modal-close');

        function showModal(message) {
            modalMessageText.textContent = message;
            modal.style.display = 'flex';
        }

        closeModalButton.onclick = function() {
            modal.style.display = 'none';
        }

        window.onclick = function(event) {
            if (event.target == modal) {
                modal.style.display = 'none';
            }
        }

        // --- Canvas and Grid Setup ---
        const canvas = document.getElementById('pathfindingCanvas');
        const ctx = canvas.getContext('2d');
        const toolSelect = document.getElementById('tool');
        const startButton = document.getElementById('startButton');
        const resetButton = document.getElementById('resetButton');
        const clearObstaclesButton = document.getElementById('clearObstaclesButton');
        const gridSizeSlider = document.getElementById('gridSize');
        const gridSizeLabel = document.getElementById('gridSizeLabel');
        const speedSelect = document.getElementById('speed');
        const statusDisplay = document.getElementById('status');

        let COLS = 20;
        let ROWS = 20;
        let CELL_SIZE;
        let grid = [];
        let startNode = null;
        let endNode = null;
        let currentTool = 'obstacle';
        let isDrawing = false;
        let animationSpeed = 50; // ms per step

        // Node colors
        const NODE_COLORS = {
            empty: '#475569',    // slate-600
            start: '#34d399',    // emerald-400
            end: '#f87171',      // red-400
            obstacle: '#1e293b', // slate-800 (darker for contrast)
            openSet: '#60a5fa',  // blue-400
            closedSet: '#93c5fd',// blue-300
            path: '#facc15'      // yellow-400
        };

        // Node class for A*
        class Node {
            constructor(x, y, isObstacle = false) {
                this.x = x; // Grid column
                this.y = y; // Grid row
                this.isObstacle = isObstacle;
                this.g = Infinity; // Cost from start to this node
                this.h = 0;        // Heuristic: estimated cost from this node to end
                this.f = Infinity; // Total cost: g + h
                this.parent = null;
                this.isStart = false;
                this.isEnd = false;
            }

            getColor() {
                if (this.isStart) return NODE_COLORS.start;
                if (this.isEnd) return NODE_COLORS.end;
                if (this.isObstacle) return NODE_COLORS.obstacle;
                return NODE_COLORS.empty;
            }
        }

        function heuristic(nodeA, nodeB) {
            // Manhattan distance
            return Math.abs(nodeA.x - nodeB.x) + Math.abs(nodeA.y - nodeB.y);
        }

        function initializeGrid() {
            grid = [];
            for (let y = 0; y < ROWS; y++) {
                const row = [];
                for (let x = 0; x < COLS; x++) {
                    row.push(new Node(x, y));
                }
                grid.push(row);
            }
            // Default start and end nodes (can be changed by user)
            if (ROWS > 1 && COLS > 1) {
                 // Place start and end somewhat apart and not on edges if possible
                const startX = Math.floor(COLS * 0.2);
                const startY = Math.floor(ROWS * 0.5);
                const endX = Math.floor(COLS * 0.8);
                const endY = Math.floor(ROWS * 0.5);

                if (grid[startY] && grid[startY][startX]) {
                    startNode = grid[startY][startX];
                    startNode.isStart = true;
                    startNode.g = 0;
                    startNode.f = heuristic(startNode, endNode || {x: endX, y: endY}); // Temp endNode for heuristic if not set
                }
                if (grid[endY] && grid[endY][endX]) {
                    endNode = grid[endY][endX];
                    endNode.isEnd = true;
                    if(startNode) startNode.f = heuristic(startNode, endNode); // Update startNode's f if endNode is now set
                }
            }
        }
        
        function resizeCanvas() {
            const container = canvas.parentElement;
            const size = Math.min(container.clientWidth, container.clientHeight);
            canvas.width = size;
            canvas.height = size;
            CELL_SIZE = canvas.width / COLS; // COLS and ROWS are the same due to aspect-square
            drawGrid();
        }

        function drawGrid() {
            if (!ctx) return;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            for (let y = 0; y < ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    const node = grid[y][x];
                    ctx.fillStyle = node.getColor();
                    ctx.fillRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                    ctx.strokeStyle = '#334155'; // slate-700 for grid lines
                    ctx.strokeRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                }
            }
        }
        
        function handleCanvasClick(event) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            
            let clientX, clientY;
            if (event.touches && event.touches.length > 0) {
                clientX = event.touches[0].clientX;
                clientY = event.touches[0].clientY;
            } else {
                clientX = event.clientX;
                clientY = event.clientY;
            }

            const x = Math.floor(((clientX - rect.left) * scaleX) / CELL_SIZE);
            const y = Math.floor(((clientY - rect.top) * scaleY) / CELL_SIZE);

            if (x >= 0 && x < COLS && y >= 0 && y < ROWS) {
                const clickedNode = grid[y][x];
                if (clickedNode.isObstacle && currentTool !== 'erase' && currentTool !== 'start' && currentTool !== 'end') return; // Don't override obstacle unless erasing or setting start/end

                switch (currentTool) {
                    case 'start':
                        if (startNode) {
                            startNode.isStart = false;
                            startNode.g = Infinity; // Reset old start node
                        }
                        startNode = clickedNode;
                        startNode.isStart = true;
                        startNode.isObstacle = false;
                        startNode.g = 0;
                        if (endNode) startNode.f = heuristic(startNode, endNode);
                        break;
                    case 'end':
                        if (endNode) endNode.isEnd = false; // Reset old end node
                        endNode = clickedNode;
                        endNode.isEnd = true;
                        endNode.isObstacle = false;
                        if (startNode) startNode.f = heuristic(startNode, endNode); // Update start node's heuristic
                        break;
                    case 'obstacle':
                        if (!clickedNode.isStart && !clickedNode.isEnd) {
                            clickedNode.isObstacle = true;
                        }
                        break;
                    case 'erase':
                        if (!clickedNode.isStart && !clickedNode.isEnd) {
                             clickedNode.isObstacle = false;
                        }
                        break;
                }
                drawGrid();
            }
        }

        function handleCanvasMouseMove(event) {
            if (!isDrawing) return;
             // Use preventDefault to avoid page scroll on touch devices while drawing
            event.preventDefault();

            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;

            let clientX, clientY;
            if (event.touches && event.touches.length > 0) {
                clientX = event.touches[0].clientX;
                clientY = event.touches[0].clientY;
            } else {
                clientX = event.clientX;
                clientY = event.clientY;
            }
            
            const x = Math.floor(((clientX - rect.left) * scaleX) / CELL_SIZE);
            const y = Math.floor(((clientY - rect.top) * scaleY) / CELL_SIZE);

            if (x >= 0 && x < COLS && y >= 0 && y < ROWS) {
                const node = grid[y][x];
                if (!node.isStart && !node.isEnd) {
                    if (currentTool === 'obstacle') {
                        node.isObstacle = true;
                    } else if (currentTool === 'erase') {
                        node.isObstacle = false;
                    }
                    drawGrid();
                }
            }
        }
        
        // Event Listeners
        toolSelect.addEventListener('change', (e) => currentTool = e.target.value);
        
        gridSizeSlider.addEventListener('input', (e) => {
            COLS = parseInt(e.target.value);
            ROWS = COLS; // Keep it square
            gridSizeLabel.textContent = COLS;
            resetFullGrid();
        });
        
        speedSelect.addEventListener('change', (e) => animationSpeed = parseInt(e.target.value));

        canvas.addEventListener('mousedown', (e) => {
            isDrawing = true;
            handleCanvasClick(e); // Handle single click for start/end, and start of drawing for obstacles
        });
        canvas.addEventListener('mouseup', () => isDrawing = false);
        canvas.addEventListener('mouseleave', () => isDrawing = false); // Stop drawing if mouse leaves canvas
        canvas.addEventListener('mousemove', handleCanvasMouseMove);

        // Touch events
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault(); // Prevent scrolling while drawing
            isDrawing = true;
            handleCanvasClick(e);
        }, { passive: false });
        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            isDrawing = false;
        });
        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault(); // Prevent scrolling while drawing
            handleCanvasMouseMove(e);
        }, { passive: false });


        startButton.addEventListener('click', runAStar);
        resetButton.addEventListener('click', resetFullGrid);
        clearObstaclesButton.addEventListener('click', () => {
            grid.forEach(row => row.forEach(node => {
                if (node.isObstacle) node.isObstacle = false;
            }));
            // Reset algorithm state without moving start/end
            resetAlgorithmState();
            drawGrid();
            statusDisplay.textContent = "Obstacles cleared.";
        });
        
        function resetFullGrid() {
            startNode = null;
            endNode = null;
            initializeGrid();
            resizeCanvas(); // This calls drawGrid
            statusDisplay.textContent = "Grid reset. Set start, end, and obstacles.";
        }

        function resetAlgorithmState() {
            // Resets G, H, F scores and parent pointers, keeps obstacles, start, end
            for (let y = 0; y < ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    const node = grid[y][x];
                    node.g = Infinity;
                    node.h = 0; // Will be recalculated if needed
                    node.f = Infinity;
                    node.parent = null;
                    // Keep node.isObstacle, node.isStart, node.isEnd
                }
            }
            if (startNode) {
                startNode.g = 0;
                if (endNode) startNode.h = heuristic(startNode, endNode); else startNode.h = 0;
                startNode.f = startNode.g + startNode.h;
            }
        }


        async function runAStar() {
            if (!startNode || !endNode) {
                showModal("Please set both a start and an end node before starting the search.");
                return;
            }
            
            startButton.disabled = true;
            resetButton.disabled = true;
            clearObstaclesButton.disabled = true;
            gridSizeSlider.disabled = true;
            toolSelect.disabled = true;
            statusDisplay.textContent = "Searching...";

            resetAlgorithmState(); // Clear previous run's data (colors, scores) but keep obstacles

            const openSet = [startNode];
            const closedSet = [];

            startNode.h = heuristic(startNode, endNode);
            startNode.f = startNode.g + startNode.h;

            while (openSet.length > 0) {
                // Find node with lowest F score in openSet
                let lowestIndex = 0;
                for (let i = 1; i < openSet.length; i++) {
                    if (openSet[i].f < openSet[lowestIndex].f) {
                        lowestIndex = i;
                    }
                }
                let current = openSet[lowestIndex];

                // If current is the end node, path found
                if (current === endNode) {
                    statusDisplay.textContent = "Path found!";
                    await reconstructPath(current);
                    enableControls();
                    return;
                }

                // Move current from openSet to closedSet
                openSet.splice(lowestIndex, 1);
                closedSet.push(current);

                // Visualize current node processing (except start/end)
                if (current !== startNode && current !== endNode) {
                    ctx.fillStyle = NODE_COLORS.closedSet;
                    ctx.fillRect(current.x * CELL_SIZE, current.y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                    ctx.strokeRect(current.x * CELL_SIZE, current.y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                }
                await new Promise(resolve => setTimeout(resolve, animationSpeed));


                // Get neighbors
                const neighbors = getNeighbors(current);
                for (const neighbor of neighbors) {
                    if (closedSet.includes(neighbor) || neighbor.isObstacle) {
                        continue;
                    }

                    const tempG = current.g + 1; // Assuming cost of 1 to move to neighbor

                    let newPathFound = false;
                    if (!openSet.includes(neighbor)) {
                        openSet.push(neighbor);
                        // Visualize neighbor being added to open set
                         if (neighbor !== startNode && neighbor !== endNode) {
                            ctx.fillStyle = NODE_COLORS.openSet;
                            ctx.fillRect(neighbor.x * CELL_SIZE, neighbor.y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                            ctx.strokeRect(neighbor.x * CELL_SIZE, neighbor.y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                        }
                        newPathFound = true;
                    } else if (tempG >= neighbor.g) {
                        continue; // This is not a better path
                    }
                    
                    // This is the best path so far to this neighbor
                    neighbor.g = tempG;
                    neighbor.h = heuristic(neighbor, endNode);
                    neighbor.f = neighbor.g + neighbor.h;
                    neighbor.parent = current;
                }
                 await new Promise(resolve => setTimeout(resolve, animationSpeed / 2)); // Shorter delay for inner loop
            }

            statusDisplay.textContent = "No path found.";
            showModal("No path could be found between the start and end nodes.");
            enableControls();
        }

        function getNeighbors(node) {
            const neighbors = [];
            const { x, y } = node;
            // Cardinal directions (no diagonals for simplicity here, but A* can handle them)
            if (x > 0) neighbors.push(grid[y][x - 1]);
            if (x < COLS - 1) neighbors.push(grid[y][x + 1]);
            if (y > 0) neighbors.push(grid[y - 1][x]);
            if (y < ROWS - 1) neighbors.push(grid[y + 1][x]);
            
            // Optional: Add diagonal neighbors
            // if (x > 0 && y > 0) neighbors.push(grid[y-1][x-1]);
            // if (x < COLS - 1 && y > 0) neighbors.push(grid[y-1][x+1]);
            // if (x > 0 && y < ROWS - 1) neighbors.push(grid[y+1][x-1]);
            // if (x < COLS - 1 && y < ROWS - 1) neighbors.push(grid[y+1][x+1]);

            return neighbors;
        }

        async function reconstructPath(current) {
            const path = [];
            let temp = current;
            while (temp.parent) {
                path.push(temp);
                temp = temp.parent;
            }
            path.push(temp); // Add the start node
            path.reverse();

            for (const node of path) {
                if (node !== startNode && node !== endNode) {
                    ctx.fillStyle = NODE_COLORS.path;
                    ctx.fillRect(node.x * CELL_SIZE, node.y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                    ctx.strokeRect(node.x * CELL_SIZE, node.y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                    await new Promise(resolve => setTimeout(resolve, animationSpeed));
                }
            }
        }
        
        function enableControls() {
            startButton.disabled = false;
            resetButton.disabled = false;
            clearObstaclesButton.disabled = false;
            gridSizeSlider.disabled = false;
            toolSelect.disabled = false;
        }

        // Initial setup
        window.addEventListener('load', () => {
            resetFullGrid(); // Initializes grid, sets default start/end, and draws
            window.addEventListener('resize', resizeCanvas);
        });

    </script>
</body>
</html>
